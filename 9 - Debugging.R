###########################
## Defensive programming ##
###########################
# 1) Checking that inputs are correct (i.e. check that input are scalars)
# 2) Avoid non-standard evaluation (i.e. subset(), transform(), with(), ...)
# 3) Avoid functions that can return different types of output 
#    -->  Whenever subsetting a dataframe in a function, always use drop=FALSE
#    -->  Never use sapply() inside a function --> always use vapply() 
#          --> vapply() throw an error if the inputs are incorrect types and 
#              return the correct type of output even for zero-length inputs 

## Fatal errors are raised by stop() 
# --> Force all execution to terminate.
# --> Errors are used when there is no way for a function to continue.

## Warnings are generated by warning() 
# --> Used to display potential problems 

## Messages are generated by message() 
# --> Used to give informative output in a way that can easily be 
#     suppressed by the user --> ?suppressMessages  
# --> Can use messages to let the user know what value the function has chosen for an important missing argument.

# Interrupts can't be generated directly by the programmer, but are raised when 
#  the user attempts to terminate execution by pressing Escape, or Ctrl + C 

## Browsing on error 
## - breakpoints (clicking left of the line number) or browser()
#   --> block the compilation to the line with the breakpoints or browser()
#   --> Use ctrl+alt+b or ctrl+alt+e to try to compile all the code
# - traceback() lists the sequence of calls that lead to the error.
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) {
  message('This is a message') 
  warnings('This is a warning')
  warnings('This is a warning')
  2 + d
}
f(10) 

# - Start only once an interactive console in the environment 
#   where the error occurred ! 
getOption("error")
browseOnce <- function() {
  old <- getOption("error")
  function() {
    options(error = old)
    browser()
  }
}
options(error = browseOnce())
# - Simply break the compilation when an error occurs 
#   where the error occurred !
simplyBreak <- function() {
   function() {
     .rs.breakOnError(TRUE)
   }
}
options(error = simplyBreak())

# - Enter the environment of any of the calls in the call stack. 
options(error = recover)
# - trace() inserts arbitrary code at any position in an existing function
#   --> To remove tracing from a function --> untrace()

## Inspect why warnings occur 
#  The easiest way to track down warnings is to convert them into errors
#   with options(warn = 2) and use the regular debugging tools.
getOption("warn") # default is 0  
options("warn" = 2)
f(10)
options("warn" = 0)

##  Convert message in error (and interrupt the code)
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}
f(10)
message2error(f())
traceback()



##############################
## Condition handling tools ##
##############################
# - try()  : continues the execution even when an error occurs
# - tryCatch() : lets specify handler functions that control what happens 
# - withCallingHandlers() : variant of tryCatch()
# --> allow to take specific actions when a condition occurs.
f1 <- function(x) {
  log(x)
  10
}
f1("x")

f2 <- function(x) {
  try(log(x))
  10
}
f2("a")

# To pass larger blocks of code to try(), wrap them in {}:
try({
      a <- 1
      b <- "x"
      a + b   
     })

# If the evaluation is unsuccessful, try will return an (invisible) object of class "try-error
failure <- try(1 + 2)
failure 
failure <- try("a" + "b")
failure
class(failure) #try-error class

# Test for the try-error class
is.error <- function(x) inherits(x, "try-error")
is.error(failure)

# try() is particularly useful when you're applying a function to multiple elements in a list 
elements <- list(1:10, c(-1, 10), c(TRUE, FALSE), letters)
results <- lapply(elements, function(x) try(log(x)))
succeeded <- !vapply(results, is.error, logical(1))
str(elements[!succeeded]) #inputs that failed

 
## tryCatch() with finally.
# --> It specifies a block of code (not a function) to run regardless of
#     whether the initial expression succeeds or fails.
#     This can be useful for clean up (e.g., deleting files, closing connections).
#     This is functionally equivalent to using on.exit()  
 
col_means <- function(df) {
  numeric <- sapply(df, is.numeric)
  numeric_cols <- df[, numeric, drop=FALSE]
  
  data.frame(lapply(numeric_cols, mean))
}
 
col_means(mtcars)
col_means(mtcars[, "mpg", drop = F])


col_means(1:10)
col_means(mtcars[, 0])
col_means(mtcars[0, ])


col_means(as.matrix(mtcars))
col_means(as.list(mtcars))

mtcars2 <- mtcars
mtcars2[-1] <- lapply(mtcars2[-1], as.character)
col_means(mtcars2)
 


